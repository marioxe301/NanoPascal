#include "lexer.h"

/*!fa2lexer
    %option generate.tokens = true;
    %file "start.jff";
    %file "identifiers.jff";

    %token.descriptions{
        Identifier = "Indentifier",
        KwProgram = "Keyword Program",
        KwVar = "Keyword Variable",
        KwArray = "Keyword Array",
        KwOf = "Keyword Of",
        KwInteger = "Keyword Integer",
        KwBool = "Keyword Boolean",
        KwChar = "Keyword Character",
        KwNot = "Keyword Not",
        KwAnd = "Keyword And",
        KwOr = "Keyword Or",
        KwXor = "Keyword XOR",
        KwShl = "Keyword Shift Left",
        KwShr = "Keyword Shift Right",
        KwDiv = "Keyword Division",
        KwMod = "Keyword Modular",
        KwBeg = "Keyword Begin",
        KwEnd = "Keyword End",
        KwBreak = "Keyword Break",
        KwIf = "Keyword If",
        KwThen = "Keyword Then",
        KwElse = "Keyword Else",
        KwWhile = "Keyword While",
        KwRepeat = "Keyword Repeat",
        KwUntil = "Keyword Until",
        KwFor = "Keyword For",
        KwDo = "Keyword Do",
        KwPrint = "Keyword Write",
        KwPrintLn = "Keyword Writeln"
    }

    %generate.state_enum(State);
*/

Token Lexer::findKeyWord(const std::string &str){
    if(str == "program"){
        return Token::KwProgram;
    }else if(str == "var"){
        return Token::KwVar;
    }else if(str == "array"){
        return Token::KwArray;
    }else if(str == "of"){
        return Token::KwOf;
    }else if(str == "integer"){
        return Token::KwInteger;
    }else if(str == "boolean"){
        return Token::KwBool;
    }else if(str == "char"){
        return Token::KwChar;
    }else if(str == "not"){
        return Token::KwNot;
    }else if(str == "and"){
        return Token::KwAnd;
    }else if(str == "or"){
        return Token::KwOr;
    }else if(str == "xor"){
        return Token::KwXor;
    }else if(str == "shl"){
        return Token::KwShl;
    }else if(str == "shr"){
        return Token::KwShr;
    }else if(str == "div"){
        return Token::KwDiv;
    }else if(str == "mod"){
        return Token::KwMod;
    }else if(str == "begin"){
        return Token::KwBeg;
    }else if(str == "end"){
        return Token::KwEnd;
    }else if(str == "break"){
        return Token::KwBreak;
    }else if(str == "if"){
        return Token::KwIf;
    }else if(str == "then"){
        return Token::KwThen;
    }else if(str == "else"){
        return Token::KwElse;
    }else if(str == "while"){
        return Token::KwWhile;
    }else if(str == "repeat"){
        return Token::KwRepeat;
    }else if(str == "until"){
        return Token::KwUntil;
    }else if(str == "for"){
        return Token::KwFor;
    }else if(str == "do"){
        return Token::KwDo;
    }else if(str == "write"){
        return Token::KwPrint;
    }else if(str == "writeln"){
        return Token::KwPrintLn;
    }else{
        return Token::Identifier;
    }
}

Token Lexer::getNextToken()
{
    text = "";
/*!fa2lexer
    %generate.lexer(text);
*/
}

const char *Lexer::tokenToString(Token tk)
{
/*!fa2lexer
    %generate.toString(tk);
*/    
}
